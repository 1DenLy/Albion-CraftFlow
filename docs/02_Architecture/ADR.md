        # Architectural Decision Records (ADR)

Документ фиксирует важные архитектурные решения, их контекст и последствия.

## ADR-001: Использование PostgreSQL в качестве основной БД
* **Статус:** Принято
* **Контекст:** Проект требует хранения рыночных данных, связей между предметами и исторической аналитики.
* **Решение:** Использовать **PostgreSQL**.
* **Обоснование:**
    1.  Необходимость сложной аналитики цен (агрегации, оконные функции), где SQL выигрывает у NoSQL.
    2.  Строгая схема данных (Schema enforcement) важна для финансовой целостности расчетов крафта.
    3.  Опыт команды в работе с реляционными СУБД.
* **Последствия:** Необходимость управления миграциями (Alembic). Чуть меньшая скорость записи сырого JSON по сравнению с MongoDB, но выигрыш в надежности выборки.

## ADR-002: Нормализация идентификаторов (Integer vs String)
* **Статус:** Принято
* **Контекст:** API Albion Online использует строковые ID (`T4_BAG`), которые длинные и занимают много места в индексах.
* **Решение:** Использовать стратегию **Нормализации**.
    * Таблицы `items` и `locations` выступают справочниками с целочисленными `id`.
    * Таблицы данных (`market_prices`, `history`) ссылаются на них через `Foreign Key (int)`.
* **Обоснование:** Экономия места на диске и в оперативной памяти (индексы по `int` работают быстрее и компактнее, чем по `string` при миллионах записей).
* **Последствия:** Модуль Ingestor обязан выполнять процедуру "Mapping" (разрешение строковых ID в числовые) перед записью.

## ADR-003: Реализация очереди задач через БД
* **Статус:** Принято
* **Контекст:** Необходимо распределять задачи на обновление цен между воркерами.
* **Решение:** Использовать таблицу `tracked_items` как очередь (паттерн Database-as-Queue).
* **Обоснование:**
    1.  **Simplicity:** Не требует поднятия и администрирования инфраструктуры брокеров (RabbitMQ/Kafka/Redis) на старте.
    2.  **Visibility:** Легко отлаживать и менять приоритеты задач простыми SQL-запросами.
* **Риски:** При очень высокой нагрузке (тысячи RPS) база может стать бутылочным горлышком из-за блокировок строк.
* **Митигация:** В будущем возможен рефакторинг на Redis/RabbitMQ, код воркера (Selector) должен быть изолирован.

## ADR-004: Стратегия обработки неизвестных предметов
* **Статус:** Принято
* **Контекст:** API может вернуть данные по предмету, которого нет в локальном справочнике `items`.
* **Решение:** **Ignore & Log**. Игнорировать запись, логировать событие "Unknown Item" уровня WARNING.
* **Обоснование:** Автоматическое создание предметов может загрязнить базу мусорными данными. Справочник должен обновляться контролируемо (через Seeds/Dumps).

## ADR-005: Политика хранения истории (Downsampling)
* **Статус:** Принято
* **Решение:** Хранить детальные данные (Raw) ограниченное время (30 дней). Старые данные агрегировать (усредение цены за сутки) или удалять в зависимости от настройки приоритета предмета.
* **Обоснование:** Предотвращение неконтролируемого роста размера БД.

## ADR-006: Изоляция Ingestor Service
* **Статус:** Принято
* **Решение:** Запуск воркера в отдельном Docker-контейнере.
* **Обоснование:** Независимое масштабирование (можно запустить 5 воркеров и 1 API) и отказоустойчивость (падение парсера не роняет API для пользователей).

## ADR-007: Стратегия наполнения базы (Database Seeding)
* **Статус:** Принято / Обновлено
* **Контекст:** Таблицы `items` (8000+ записей) и `locations` являются справочниками, необходимыми для работы системы.
* **Решение:** Асинхронный ETL-скрипт (`src/scripts/seed_db.py`).
* **Технические детали:**
    1.  **Источник:** JSON-дампы из репозитория `ao-bin-dumps` (GitHub Raw).
    2.  **Клиент:** `httpx` (асинхронный) для неблокирующей загрузки данных.
    3.  **Метод вставки:** `SQLAlchemy Core (Insert)` вместо ORM.
    4.  **Пакетная вставка (Chunking):** Данные разбиваются на пакеты по 5000 записей.
* **Обоснование:**
    * Использование ORM для массовой вставки 8000+ объектов вызывало значительные накладные расходы по памяти и CPU.
    * `Core Insert` генерирует один SQL-запрос (`INSERT INTO ... VALUES ...`), что ускоряет инициализацию в 10-20 раз.
    * Асинхронность позволяет интегрировать этот процесс в общий жизненный цикл приложения без блокировок.
## ADR-008: Ограничение нагрузки (Rate Limiting)
* **Статус:** Принято
* **Решение:** Синхронная пауза (`sleep`) внутри цикла воркера.
* **Конфигурация:** Время паузы выносится в переменные окружения (`RATE_LIMIT_DELAY=1s`).
* **Обоснование:** Простота реализации. Поскольку работает только один инстанс воркера, сложный распределенный Rate Limiter (типа Redis Token Bucket) не требуется.

## ADR-009: Конкурентный доступ (Concurrency)
* **Статус:** Отложено (Deferred)
* **Контекст:** Блокировка задач при запуске нескольких воркеров.
* **Решение:** На текущем этапе используется простой `SELECT`. Механизм `SELECT ... FOR UPDATE SKIP LOCKED` рассматривается как улучшение для версии 2.0.
* **Обоснование:** Сейчас в системе планируется только один воркер. Риск гонки отсутствует.

## ADR-010: Мониторинг здоровья (Health Check)
* **Статус:** Принято
* **Решение:** Log-based мониторинг.
* **Реализация:** Воркер пишет структурированные логи (INFO/ERROR) в `stdout`. Docker собирает логи.
* **Обоснование:** Минимальные затраты на внедрение. Если воркер упадет, Docker перезапустит контейнер (policy: restart always).