# Техническое Задание: Модуль Ingestor (Worker)

## 1. Общее описание
Консольное приложение на Python, работающее в бесконечном цикле внутри Docker-контейнера. Его задача — поддерживать актуальность цен в базе данных.

## 2. Структура модуля (Layers)
В соответствии с Clean Architecture, модуль должен быть разделен на слои:

### 2.1. Selector (Выборщик задач)
* **Функция:** `get_batch_tasks(limit=50)`
* **Логика:**
    * Делает SELECT из `tracked_items`.
    * Условия: `is_active = True`.
    * Сортировка: `last_check ASC NULLS FIRST` (сначала те, что давно не обновлялись).
    * Группировка: Возвращает список ID предметов, сгруппированных по `location_id`.

### 2.2. Albion Client (Сетевой слой)
* **Функция:** `fetch_prices(item_ids: List[str], location: str)`
* **Требования:**
    * Использовать `AlbionUrlBuilder` для генерации URL.
    * Реализовать **Retry Policy** (библиотека `tenacity`): 3 попытки при ошибках соединения.
    * Возвращать сырой JSON (или Pydantic модель ответа).

### 2.3. Processor (Обработчик)
* **Функция:** `process_data(raw_data, current_time)`
* **Логика:**
    * Фильтрация: Отбрасывать записи с ценой = 0.
    * Валидация: Проверять соответствие структуры ожидаемой схеме.
    * Маппинг: Превращать JSON Альбиона в модели `MarketPrice` и `MarketHistory`.

### 2.4. Repository (Слой данных)
* **Функция:** `save_prices(prices: List[MarketPrice])`
* **Логика (Транзакция):**
    1.  **UPSERT** в `market_prices`:
        * Если запись (item + city + quality) есть -> обновить цены и `last_updated`.
        * Если нет -> вставить новую.
    2.  **INSERT** в `market_history`:
        * Всегда добавлять новую запись с текущим временем.
    3.  **UPDATE** `tracked_items`:
        * Установить `last_check = NOW()` для всех обработанных предметов.

## 3. Алгоритм работы (Loop)
1.  Бесконечный цикл `while True`.
2.  Запросить пачку задач у `Selector`.
3.  Если задач нет -> `sleep(60)` (ждем, пока появятся).
4.  Для каждой группы (Город + Список Предметов):
    * Вызвать `Albion Client`.
    * Если ошибка API -> Логгировать, пропустить итерацию (не обновлять `last_check`, чтобы попробовать снова сразу).
    * Если успех -> `Processor` -> `Repository`.
    * Сделать паузу 1-2 секунды (Rate Limiting), чтобы не получить бан.

## 4. Используемые библиотеки
* `sqlalchemy` (ORM)
* `httpx` или `requests` (HTTP)
* `tenacity` (Retries)
* `pydantic` (Validation)